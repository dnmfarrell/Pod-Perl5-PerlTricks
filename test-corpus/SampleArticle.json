{ "body" : "\"\\n\\n<p>How can I easily run the same tests on different data without duplicating a lot of code? If I follow my usual pattern, I start off with a couple of tests where I write some code then cut-and-paste that a couple of times. I add a few more tests before I realize I have a mess. If I had the foresight to know that I would make a mess (again), I would have started with a table of data and a little bit of code that went through it.<sup><a href=\\\"#0_1\\\">1</a></sup></p>\\n\\n<p>Consider a silly and small example of testing <code>sprintf</code>-like behaviour of M<String::Sprintf>. I can use this module to create my own format specifiers, such as one to commify a number. I stole this mostly from its documentation, although I threw in the <a href=\\\"http://www.effectiveperlprogramming.com/2015/04/use-v5-20-subroutine-signatures/\\\">v5.20 signatures feature</a> and the <a href=\\\"http://www.effectiveperlprogramming.com/2010/09/use-the-r-substitution-flag-to-work-on-a-copy/\\\">v5.14 non-destructive</a> <code>/r</code> flag on the substitution operator> because I love those features:</p>\\n\\n<pre>use v5.20;\\nuse feature qw(signatures);\\nno warnings qw(experimental::signatures);\\n\\nuse String::Sprintf;\\n\\nmy $f = String::Sprintf->formatter(\\n  N => sub {\\n    my($width, $value, $values, $letter) = @_;\\n    return commify(sprintf \\\"%${width}f\\\", $value);\\n    }\\n  );\\n\\nsay \\\"Numbers are: \\\" . \\n  $f->sprintf(\\n    '%10.2N, %10.2N', \\n    12345678.901, 87654.321\\n    );\\n\\nsub commify ( $n ) {\\n  $n =~ s/(\\\\.\\\\d+)|(?<=\\\\d)(?=(?:\\\\d\\\\d\\\\d)+\\\\b)/$1 || ','/rge;\\n  }\\n\\nNumbers are: 12,345,678.90,   87,654.32</pre>\\n\\n<p>The mess I might make to test this starts with a single input and output with the M<Test::More> function <code>is</code>:</p>\\n\\n<pre>use v5.20;\\nuse feature qw(signatures);\\nno warnings qw(experimental::signatures);\\n\\nuse Test::More;\\n\\nsub commify ( $n ) {\\n  $n =~ s/(\\\\.\\\\d+)|(?<=\\\\d)(?=(?:\\\\d\\\\d\\\\d)+\\\\b)/$1 || ','/rge;\\n  }\\n\\nmy $class = 'String::Sprintf';\\nuse_ok( $class );\\n\\nmy $f = String::Sprintf->formatter(\\n  N => sub {\\n    my($width, $value, $values, $letter) = @_;\\n    return commify(sprintf \\\"%${width}f\\\", $value);\\n    }\\n  );\\n\\nisa_ok( $f, $class );\\ncan_ok( $f, 'sprintf' );\\n\\nis(  $f->sprintf( '%.2N', '1234.56' ), '1,234.56' );\\n\\ndone_testing();</pre>\\n\\n<p>I decide to test another value, and I think the easiest thing to do is to duplicate that line with <code>is</code>:</p>\\n\\n<pre>is(  $f->sprintf( '%.2N', '1234.56' ), '1,234.56' );\\nis(  $f->sprintf( '%.2N', '1234' ),    '1,234.00' );</pre>\\n\\n<p>The particular thing to test isn't the point of this article. It's all the stuff around it that I want to highlight. Or, more correctly, I want to de-emphasize all this stuff around it. I had to duplicate the test although most of the structure is the same.</p>\\n\\n<p>I can convert those tests to a structure to hold the data and another structure for the behaviour:</p>\\n\\n<pre>my @data = (\\n  [ qw( 1234.56 1,234.56 ) ],\\n  [ qw( 1234    1,234.00 ) ],\\n  );\\n\\nforeach my $row ( @data ) {\\n  is(  $f->sprintf( '%.2N', $row->[0] ), $row->[1] );\\n  }</pre>\\n\\n<p>I can add many more rows to <code>@data</code> but the meat of the code, that <code>foreach</code> loop, doesn't change.</p>\\n\\n<p>I can improve this though. So far I only test that one template. I can add that to <code>@data</code> too, and use that to make a label for the test:</p>\\n\\n<pre>my $ndot2_f = '%.2N';\\n\\nmy @data = (\\n  [ $ndot2_f, qw( 1234.56 1,234.56 ) ],\\n  [ $ndot2_f, qw( 1234    1,234.00 ) ],\\n  );\\n\\nforeach my $row ( @data ) {\\n  is(  $f->sprintf( $row->[0], $row->[1] ), $row->[2],\\n    \\\"$row->[1] with format $row->[0] returns $row->[2]\\\"\\n     );\\n  }</pre>\\n\\n<p>I can add another test with a different format. If I had kept going the way I started, this would look like a new test because the format changed. Now the format is just part of the input:</p>\\n\\n<pre>my $ndot2_f = '%.2N';\\n\\nmy @data = (\\n  [ $ndot2_f, qw( 1234.56 1,234.56 ) ],\\n  [ $ndot2_f, qw( 1234    1,234.00 ) ],\\n  [ '%.0N'  , qw( 1234.49 1,234    ) ],\\n  );\\n\\nforeach my $row ( @data ) {\\n  is(  $f->sprintf( $row->[0], $row->[1] ), $row->[2],\\n    \\\"$row->[1] with format $row->[0] returns $row->[2]\\\"\\n     );\\n  }</pre>\\n\\n<p>As I go on things get more complicated. If a test fails, I want some extra information about which one failed. I'll change up how I go through the table. In this case, I'll use the <a href=\\\"http://www.effectiveperlprogramming.com/2010/05/perl-5-12-lets-you-use-each-on-an-array/\\\">v5.12 feature</a> that allows <code>each</code> on an array so I get back the index and the value:</p>\\n\\n<pre>while( my( $index, $row ) = each @data ) {\\n  is(  $f->sprintf( $row->[0], $row->[1] ), $row->[2],\\n    \\\"$index: $row->[1] with format $row->[0] returns $row->[2]\\\"\\n     );\\n  }</pre>\\n\\n<p>My code for the test behavior changed but I didn't have to mess with the input data at all. The particular code in this case doesn't matter. This table-driven testing separates the inputs and the tests; that's what you should pay attention to.</p>\\n\\n<p>It can get even better. So far, I've put all the input data in the test file itself, but now that it's separate from the test code, I can grab the input from somewhere else, like a database table:</p>\\n\\n<table>\\n<th>ColA</th><th>ColB</th><th>ColC</th>\\n<tr><td>%.2N</td><td>1234.56</td><td>1,234.56</td></tr>\\n<tr><td>%.2N</td><td>1234</td><td>1,234.00</td></tr>\\n<tr><td>%.0N</td><td>1234.49</td><td>1,234</td></tr>\\n</table>\\n\\n<p>Or a pipe separated values file:</p>\\n\\n<pre class=\\\"data\\\">%.2N|1234.56|1,234.56\\n%.2N|1234|1,234.00\\n%.0N|1234.49|1,234</pre>\\n\\n<p>I create <code>@data</code> in the test file by reading and parsing the external file <span class=\\\"data\\\">tests.t</span>:</p>\\n\\n<pre><code>open my $test_data_fh, '<', $test_file_name or die ...;\\n\\nmy @data;\\nwhile( <$test_data_fh> ) {\\n  chomp;\\n  push @data, split /\\\\t/;\\n  }</code></pre>\\n\\n<p>I can execute the tests with <span class=\\\"terminal\\\">perl tests.t</span> Now none of the data are in the test file. And, there's nothing special about a simple text file. I could do a little bit more work to take the data from an Excel file (perhaps that most useful wizard skill in the world of business) or even a database:</p>\\n\\n<pre><code>use DBI;\\n\\nmy $dbh = DBI->connect( ... );\\nmy $sth = $dbh->prepare( 'SELECT * FROM tests' );\\n\\n$sth->execute();\\n\\nwhile( my $row = $sth->fetchrow_arrayref ) {\\n  state $index = 0;\\n\\n  is(  $f->sprintf( $row->[0], $row->[1] ), $row->[2],\\n    $index++ . \\\": $row->[1] with format $row->[0] returns $row->[2]\\\"\\n     );\\n\\n  }</code></pre>\\n\\n<p>That's the idea. I separate the data and the tests to give myself some flexibility. How I access the data and how I test depend on my particular problems.</p>\\n<div class=\\\"footnotes\\\">\\n<ul>\\n<li id=\\\"0_1\\\">[1] This is known as <a href=\\\"https://en.wikipedia.org/wiki/data-driven-testing\\\">data-driven-testing</a></li>\\n</ul>\\n</div>\\n\"", "head" : [ { "charset" : "UTF-8" }, { "lang" : "en" }, { "cover-image" : "onion_charcoal.png" }, { "title" : "Separate data and behavior with table-driven testing" }, { "subtitle" : "Applying DRY to unit testing" }, { "description" : "Table-driven testing reduces code and lowers the cost of testing. This article shows how to use table-driven testing with Perl." }, { "publish-date" : "2000-12-31T00:00:00Z" }, { "author" : "brian d foy" }, { "author-bio" : "<a href=\"http://www.pair.com/~comdog/\">brian d foy</a> (<a href=\"https://twitter.com/briandfoy_perl\">briandfoy_perl</a>) is a <a href=\"https://en.wikipedia.org/wiki/Perl\">Perl</a> trainer and writer. He's the author of Mastering Perl and co-author of Programming Perl, Learning Perl, Intermediate Perl and Effective Perl Programming. Github: <a href=\"https://github.com/briandfoy/projects\">projects</a>." }, { "author-image" : "http://static/images/brian_d_foy.png" }, { "keywords" : [ "unit", "testing", "data", "table", "perl", "tdd" ] } ] }
